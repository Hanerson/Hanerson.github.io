# 01-概述

## 人工管理 & 文件系统

| 方面      | 人工管理        | 文件系统         |
| ------- | ----------- | ------------ |
| 数据管理者   | 用户（程序员）     | 文件系统         |
| 数据保存    | 不保存         | 保存           |
| 数据面向的对象 | 某一应用程序      | 某一应用         |
| 数据的共享程度 | 无共享、冗余度极大   | 共享性差、冗余度大    |
| 数据的独立性  | 不独立，完全依赖于程序 | 独立性差         |
| 数据的结构化  | 无结构         | 记录内有结构，整体无结构 |
| 数据控制能力  | 应用程序自己控制    | 文件系统控制       |

## 数据库基本概念

* 数据：描述事物的符号记录，数据库中储存的基本对象
* 数据库：长期储存在计算机内、有组织的、可共享的大量数据的集合
    * 结构化
    * 共享度高、冗余度小
    * 独立性高：以牺牲性能为代价封装数据操作的复杂细节
        * 物理独立性：应用程序和数据的物理存储无关
        * 逻辑独立性：应用程序和数据的逻辑结构无关
    * 易扩展
* 数据库管理系统
    * 数据安全性保护
    * 数据完整性检查
    * 数据库恢复
    * 并发控制
* 数据库系统：数据库 数据库管理系统 应用程序 数据库管理员

## 数据模型

* 定义：对现实世界数据的抽象，用以**抽象、表示、处理**现实世界中的数据信息
* 满足要求
    * 比较真实的模拟现实世界
    * 容易被人所理解
    * 便于在计算机上实现
* 数据模型：数据库系统的核心和基础
* 数据结构：描述数据库的组成对象及对象间的联系
    * 与对象的类型、内容、性质有关
    * 与数据之间的联系有关
    * 对系统静态特性的描述
* 数据操作：对数据库中对象的实例允许执行操作的集合，包括操作及有关的操作规则
    * 数据操作的类型：增删改查
    * 数据模型对操作的定义：操作的确切含义、操作符号、操作规则（优先级）
    * 对系统动态特性的描述
* 数据完整性的约束条件：限定数据库状态（的变化），保证数据的正确、有效、相容

### 概念/逻辑/物理模型

| 类别       | 概述                | 应用场景   |
| -------- | ----------------- | ------ |
| 概念（信息）模型 | 按用户观点对数据和信息建模     | 数据库设计  |
| 逻辑模型     | 按计算机系统观点对数据和信息建模  | DBMS实现 |
| 物理模型     | 描述数据在系统内部的表示和存取方法 | 数据库实现  |

* （现实世界）客观对象 -> （信息世界）概念模型 -> （机器世界）数据模型

### 概念模型

* 实体 Entity：客观存在且可区分的事物
* 属性 Attribute：实体的特征
* 码 Key：唯一标识实体的属性集
* 实体型 Entity **Type**：具有相同属性的实体集合，相当于编程中的**类型**
* 实体集 Entity **Set**：同一实体型的实体集合，相当于编程中的**数组**
* 联系 Relationship：事物内部/之间的联系，即实体（型）内部的联系和实体（型）之间的联系
    * 实体之间的联系：1:1、1:N、M:N
    * 实体内部的联系：各属性之间的联系
* 实体联系方法 Entity-Relationship Model：描述实体、属性、联系的模型，即 E-R 图
    * 实体：矩形
    * 属性：椭圆
    * 联系：菱形

### 常用数据模型

* 格式化模型
    * 层次模型
    * 网状模型
* 关系模型
* 对象模型
    * 面向对象数据模型
    * 对象关系数据模型

### 关系模型

* 关系 Relation：二维表，由行和列组成
* 元组 Tuple：表中的一行
* 属性 Attribute：表中的一列
* 主码 Primary Key：唯一标识元组的属性集
* 域：具有相同数据类型的值的集合。（取值范围）
* 外码 Foreign Key：表中的属性，引用另一表的主码
* 关系模式 Relation Schema：关系的描述，`关系名(属性1, 属性2, ...)`
* 关系模型必须是规范化的，每一个分量是不可分的数据项，属性不能再分

#### 关系模型的操作和完整性

* 增删查改都是对关系的集合操作
* 关系模型隐蔽了数据的物理存储细节
* 关系模型的完整性
    * 实体完整性：主码非空
    * 参照完整性：外码必须是另一表的主码
    * 用户定义完整性：用户自定义的完整性约束

#### 关系模型的优缺点

* 优点
    * 建立在严格的数学概念技术上
    * 概念单一
    * 关系模型的存取路径对用户透明
        * 具有更高的数据独立性、安全保密性
        * 简化了程序员的工作和数据库开发建立的工作
* 缺点
    * 查询效率低
    * 增加了开发 DBMS 的难度

## 数据库系统的结构

* 开发人员角度：三级模式结构
    * 外模式：用户视图
    * 模式：数据库的全局逻辑结构
    * 内模式：数据库的物理存储结构
* 最终用户角度
    * 单用户结构
    * 主从式结构
    * 分布式结构
    * 客户-服务器结构
    * 浏览器-服务器结构/数据库服务器多层结构

### 模式 实例

* 模式 Schema：数据库**全体**逻辑结构和特征的描述，包含数据的逻辑结构、数据之间的联系、数据的安全性、完整性
    * 相对稳定，一个数据库只有一个模式
    * 不涉及具体的值
    * 中间层：与硬件/软件无关
    * 所有用户的公共视图
* 实例 Instance：数据库某一时刻的状态
    * 模式的具体值，随数据库更新而变动
* 外模式 External Schema：数据库用户使用的**局部数据**的逻辑结构和特征描述
    * 也称子模式/用户模式
    * 用户视图，和应用有关的数据的逻辑表示
    * 介于模式和应用之间
    * 模式和外模式：一对多
    * 外模式和应用：一对多
    * 保证数据库安全：用户只能访问外模式中的有限数据
* 内模式 Internal Schema：数据物理结构和存储方式的描述
    * 底层相关
    * 一个数据库只有一个内模式
* 三级模式：外模式 -> 模式 -> 内模式
* 二级映像
    * 外模式/模式映像：每一个外模式，数据库系统都有一个外模式/模式映像，定义外模式和模式的对应关系
        * 保证数据（与程序）的逻辑独立性：模式改变时，管理员只需改变映像，而不用改变外模式和应用程序
    * 模式/内模式：唯一，定义了数据全局逻辑结构和储存结构的对应关系
        * 保证数据（与程序）的物理独立性：内模式改变时，管理员只需改变映像，而不用改变模式

## 数据库系统的组成

* 硬件平台：足够大的内存、磁盘、较高的通道能力
* 软件：DBMS、OS、编译系统、开发工具、数据库应用系统
* 人员：数据库管理员、系统分析员和数据库设计人员、应用程序员、最终用户

# 02-关系模型

## 基础概念

* 域：具有相同数据类型的值的集合。（取值范围）

### 笛卡尔积

* 笛卡尔积：给定一组域$$D_1, D_2, \cdots, D_n$$，它们的笛卡尔积是$$\{(d_1, d_2, \cdots, d_n) | d_i \in D_i\}$$
* 元组：笛卡尔积中的元素
* 分量：每个元素$$(d_1, d_2, \cdots, d_n)$$中的$$d_i$$
* 基数：元组的个数，$$|\prod_{i=1}^{n} D_i| = \prod_{i=1}^{n} |D_i|$$
* 笛卡尔积的表示方法：二维表，行是元组，列是域

### 关系

* 关系：$$\prod_{i=1}^{n} D_i$$的子集，叫做在域$$D_1, D_2, \cdots, D_n$$上的关系，表示为$$R(D_1, D_2, \cdots, D_n)$$
    * $$R$$：关系名
    * $$n$$：关系的度，$$n$$元关系
* 元组：关系中的每个元素，用$$t$$表示
* 也可用二维表表示
* 属性：每一列的名字
* 码
    * 候选码 Candidate Key：唯一标识元组的属性集，且其任意真子集都不能唯一标识元组
    * 主码：选定多个候选码中的一个
    * 主属性：主码中的属性
    * 外码：表中的属性，引用另一表的主码

#### 关系的类别

* 基本关系：实际存在的表，实际储存数据的逻辑表示
* 查询表：查询结果对应的表
* 视图表：由基本表或其他视图表导出的表，是虚表，不对应实际储存的数据

#### 基本关系的性质

* 列是同质的：每一列中的分量来自同一个域
* 不同的列可以出自同一个域：不同列的定义域可能相同
* 行、列的顺序无关紧要
* 任何两个元组的候选码不能相同
* 分量必须取原子值：每一个分量都是不可再分的数据项

#### 关系模式

* 对关系的描述，静态的、稳定的
    * 关系是动态的
* 定义：$$R(U,D,DOM,F)$$
    * $$R$$：关系名
    * $$U$$：属性名
    * $$D$$：属性的域
    * $$DOM$$：属性向域的映像集合
    * $$F$$：属性间的数据依赖关系
* 可简记为 $$R(U)$$ 或 $$R(A_1,A_2,\cdots,A_n)$$，$$A_i$$ 是属性名

### 关系数据库

* 所有关系的集合构成关系数据库
* 关系数据库的型: 关系数据库模式，是对关系数据库的描述
* 关系数据库的值: 关系模式在某一时刻对应的关系的集合，通常称为关系数据库

## 关系的完整性

* 实体完整性：主属性非空（不存在、无意义的数据）
* 参照完整性：当关系$$R_1$$的外码引用关系$$R_2$$的主码时，$$R_1$$的每个元组的外码值必须是$$R_2$$的某个元组的主码值或空值
* 用户定义完整性：用户自定义的完整性约束

## 关系操作 & 关系代数

### 集合运算

* 并：$$R \cup S = \{t | t \in R \lor t \in S\}$$，$$R$$ 和 $$S$$ 的属性、目数必须相同
* 交：$$R \cap S = \{t | t \in R \land t \in S\}$$，$$R$$ 和 $$S$$ 的属性、目数必须相同
* 差：$$R - S = \{t | t \in R \land t \notin S\}$$，$$R$$ 和 $$S$$ 的属性、目数必须相同
* 笛卡尔积
    * $$R$$：$$n$$目关系，$$k_1$$个属性
    * $$S$$：$$m$$目关系，$$k_2$$个属性
    * $$R \times S$$：$$n+m$$目关系，$$k_1*k_2$$个属性
    * $$R \times S = \{\overset{\frown}{t_1 t_2} | t_1 \in R \land t_2 \in S\}$$
    * $$\overset{\frown}{t_1 t_2}$$：$$t_1$$ 和 $$t_2$$ 的连接

### 关系运算

* 选择（行的运算）：$$\sigma_{F}(R)=\{t | t \in R \land F(t)\}$$，$$F$$ 是布尔表达式（返回真或假），筛选满足 $$F$$ 的元组
* 投影（列的运算）：$$\Pi_{A}(R)=\{t[A] | t \in R\}$$，$$A$$ 是属性名，筛选 $$A$$ 对应的列
    * 可能会导致行的减少：列删除后可能会产生重复的元组
* 连接：$$R \underset{A \theta B}{\bowtie} S = \{\overset{\frown}{t_r t_s} | t_r \in R \land t_s \in S \land (t_r[A] \theta t_s[B])\}$$
    * 在笛卡尔积后，选择符合条件，即$$t_r[A] \theta t_s[B]$$为真的元组
    * 等值连接：$$\theta$$ 是等于号，比较两个属性的值是否相等（不合并相同属性列）
    * 自然连接：特殊的等值连接，合并$$R$$ 和 $$S$$ 的相同属性列
    * 悬浮元组 Dangling tuple：在自然连接中，$$R$$ 中某些元组有可能在$$S$$中不存在公共属性上值相等的元组，导致$$R$$ 中的元组被舍弃
    * 外连接：保留悬浮元组，空值填充 `NULL`
    * 左/右外连接：只保留左/右表的悬浮元组，悬浮元组中右/左表独有的属性置为 `NULL`
* 除（行和列的运算）：$$R \div S = \{t_r[X] | t_r \in R \land \Pi_Y(S)\subseteq Y_X \}$$，$$A$$ 和 $$B$$ 是属性名
    * $$R$$有属性$$X$$和$$Y$$，$$S$$有属性$$Y$$,$$Z$$，$$Y_R$$和$$Y_S$$的域相同
    * 找出满足所有$$Y$$的$$X$$（$$X$$的象集能够包含$$\pi_Y(S)$$）
    * $$x$$在$$R$$中的象集：$$Y_x=\{t[Y] | \exists t \in R, t[X]=x\}$$

# 03-SQL

* SQL 结构化查询语言：关系数据库的标准语言
    * 综合统一
    * 命令式语言，非过程化
    * 面向集合的操作方式

## SQL 与 关系数据库三级模式

* 存储文件：对应内模式
* 基本表：对应模式
    * 一个关系对应一个基本表
    * 一个表可带若干索引
* 视图：对应外模式
    * 从基本表导出的表
    * 数据库中只存放视图的定义而不存放视图对应的数据
    * 视图是一个虚表
    * 用户可以在视图上再定义视图

## SQL 数据定义

### 层次化机制

* 一个数据库实例可以建立多个数据库
* 一个数据库可以建立多个模式
* 一个模式包含多个表、视图、索引等对象

### 数据定义语法

| 对象 | 创建              | 删除            | 修改            |
| -- | --------------- | ------------- | ------------- |
| 模式 | `CREATE SCHEMA` | `DROP SCHEMA` |               |
| 表  | `CREATE TABLE`  | `DROP TABLE`  | `ALTER TABLE` |
| 视图 | `CREATE VIEW`   | `DROP VIEW`   |               |
| 索引 | `CREATE INDEX`  | `DROP INDEX`  | `ALTER INDEX` |

* 没有修改模式：避免增加复杂性
* 注：MySQL 创建数据库时，模式和数据库是同义词，会创建同名的模式

#### 模式

*   定义模式

    ```sql
      CREATE SCHEMA <schema_name> AUTHORIZATION <user_name> 
        [ CREATE TABLE <table_name> ] 
        [ CREATE VIEW <view_name> ]
        [ GRANT <privilege> ON <object_name> TO <user_name> ]
    ```
*   删除模式

    * `CASCADE`：删除模式下的所有对象
    * `RESTRICT`：不删除模式下的对象，如果有对象存在则拒绝执行，仅当没有对象存在时才执行

    ```sql
      DROP SCHEMA <schema_name> <CASCADE | RESTRICT>
    ```

#### 表

*   定义基本表

    * 约束条件
        * 列约束：
            * `NOT NULL`：非空约束
            * `UNIQUE`：唯一约束
            * `CHECK (<condition>)`：检查约束
            * `DEFAULT <default_value>`：默认值约束
            * `PRIMARY KEY`：主键约束
        * 表约束：
            * `PRIMARY KEY (<column_name>, [<column_name>])`：主键约束，可以包含多个列
            * `FOREIGN KEY (<column_name>) REFERENCES <table_name> (<column_name>)`：外键约束

    ```sql
      CREATE TABLE <table_name> (
        <column_name> <data_type> [<column_constraint>],
        ...
        [<table_constraint>]
      )
    ```
*   修改基本表：

    * `ADD`：添加列，新增列一律为空值
    * `DROP`：删除列
    * `ALTER`：修改列
    * `RENAME`：重命名表

    ```sql
      ALTER TABLE <table_name> 
        [ ADD[COLUMN]  <column_name> <data_type> [<column_constraint>]] 
        [ ADD <table_constraint> ]
        [ DROP [COLUMN] <column_name> [CASCADE | RESTRICT] ]
        [ DROP CONSTRAINT <constraint_name> [CASCADE | RESTRICT] ]
        [ ALTER COLUMN <column_name> <data_type> ]
    ```
*   删除基本表

    * `CASCADE`：删除表和相关的所有依赖对象
    * `RESTRICT`：若该表存在依赖对象/引用，则拒绝删除

    ```sql
      DROP TABLE <table_name> [CASCADE | RESTRICT]
    ```

#### 索引

* 索引：加快查询速度
* 由数据库系统自动维护
* 常见索引
    * 顺序文件索引
    * B+树索引
    * 哈希索引
    * 位图索引：bitmap
*   建立索引

    * 索引可以建立在一列/多列上
    * 次序：`ASC`：升序（默认），`DESC`：降序
    * `UNIQUE`：唯一索引，索引对应唯一数据记录
    * `CLUSTER`：聚簇索引，根据索引重新排列物理储存聚簇，提高查询效率

    ```sql
      CREATE [UNIQUE] [CLUSTER] INDEX <index_name> ON <table_name> (<column_name> [ASC | DESC], ...)
    ```
*   修改索引

    ```sql
      ALTER INDEX <index_name> RENAME TO <new_index_name>
    ```
*   删除索引

    ```sql
      DROP INDEX <index_name>
    ```

## SQL 数据类型

* 字符串
    * `CHAR(n)`, `CHARACTER(n)`：定长字符串
    * `VARCHAR(n)`, `CHARACTER VARYING(n)`：变长字符串
    * `NCHAR(n)`, `NVARCHAR(n)`: 定长/变长字符串，Unicode 字符集
* `CLOB(n)`, `TEXT`: 大文本
* `BLOB(n)`: 二进制大对象
* 数值
    * `SMALLINT`: 2字节整数
    * `INT`, `INTEGER`: 4字节整数
    * `BIGINT`: 8字节整数
    * `REAL`: 单精度浮点数（取决于机器精度）
    * `DOUBLE PRECISION`: 双精度浮点数（取决于机器精度）
    * `FLOAT(n)`: n位精度浮点数
    * `DECIMAL(p, d)`, `NUMERIC(p,d)`, `DEC(p, d)`: 定点数，p: 位数，d: 小·数位数
* 时间
    * `DATE`: 日期
    * `TIME`: 时间
    * `TIMESTAMP`: 时间戳
    * `INTERVAL`: 时间间隔
* `BOOLEAN`: 布尔值
* 选取属性的原则
    * 数据的取值范围
    * 数据需要做的运算

## 数据字典

* 数据库管理系统的内部表
* 记录关系模式、视图、索引、完整性约束、操作权限、统计信息等定义和信息
* SQL 语句执行时更新数据字典的内容

## SQL 数据查询

* `SELECT` 要显示的列
    * 目标列表达式可以是表达式/函数，如`<column_name> + 1`，`LOWER(<column_name>)`
    * 可以使用`AS`给列起别名，也可以不用`AS`，如`SELECT <column_name> AS <alias_name>`，`SELECT <column_name> <alias_name>`
    * `DISTINCT`：去重
    * `ALL`：保留重复值（默认）
    * `*`：所有列
* `FROM` 要查询的表/视图
* `WHERE` 查询条件
    * 比较运算符：`=`, `<>`, `!=`, `<`, `<=`, `>`, `>=`，`!<`, `!>`, `NOT + 运算符`
    * 范围：`BETWEEN <low> AND <high>`，`NOT BETWEEN <low> AND <high>`
    * 包含：`IN (<value>, ...)`，`NOT IN (<value>, ...)`
    * 字符匹配
        * `LIKE`：模糊匹配，`%`表示0个或多个任意字符，`_`表示单个字符
        * `NOT LIKE`
        * 指定转义符：`ESCAPE <escape_char>`，如`LIKE 'A\%' ESCAPE '\'`查询`A%`
    * 空值：`IS NULL`，`IS NOT NULL`
    * 逻辑运算符：`AND`, `OR`, `NOT`
        * 优先级：`NOT` > `AND` > `OR`
        * 可使用括号更改优先级
* `GROUP BY` 按照指定列的值分组
* `HAVING` 分组后的条件
* `ORDER BY` 排序
    * 根据多个列排序：前面的列优先级高

```sql
SELECT [ALL | DISTINCT] <column_name_expr> [ [AS] <column_alias_name>], ...
FROM <table_name|view_name>, ...| (SELECT ...) [AS <alias_name>]
WHERE <condition>
GROUP BY <column_name>, ...
HAVING <condition>
ORDER BY <column_name> [ASC | DESC]
```

{% hint style="warning" %}
关系运算中的投影需要去重，对应于 SQL 中的 `DISTINCT`
{% endhint %}

### 聚集函数

* `COUNT(*)`：统计行数
* `COUNT([DISTINCT|ALL] <column_name>)`：统计列数，默认为`ALL`
* `SUM([DISTINCT|ALL] <column_name>)`：求和，默认为`ALL`
* `AVG([DISTINCT|ALL] <column_name>)`：平均值，默认为`ALL`
* `MIN([DISTINCT|ALL] <column_name>)`：最小值，默认为`ALL`
* `MAX([DISTINCT|ALL] <column_name>)`：最大值，默认为`ALL`
* 除了`COUNT(*)`，其他聚集函数跳过空值

### 对查询结果分组

* `GROUP BY`：分组
* 对查询结果分组后，聚集函数将分别作用于每个组
*   `HAVING`作用于分组后的结果，`WHERE`作用于分组前的所有结果

    * 例：查询平均成绩大于等于90分的学生学号和平均成绩

    ```sql
     SELECT SNO, AVG(SCORE) AS AVG_SCORE
     FROM SC
     GROUP BY SNO
     HAVING AVG(SCORE) >= 90
    ```

### 连接查询

* 连接查询：同时涉及两个以上的表的查询

#### 连接查询求解方法

* 嵌套循环法：在表中找到第一个元组后，在第二个表中找到符合条件的元组，直到找到所有符合条件的元组，时间复杂度为$$O(n^2)$$
* 排序合并法：（用于等值连接）
    * 将两个表按照连接条件的属性进行排序
    * 将两个表进行合并，时间复杂度为$$O(nlogn)$$
* 索引链接法：
    * 对表 2 按连接字段建立索引
    * 对表 1 中的每个元组，利用索引在表 2 中查找符合条件的元组进行拼接
    * 时间复杂度为$$O(nlogm)$$，$$m$$为表 2 的记录数
*   等值连接：连接条件是等值关系

    * 例：查询每个学生及其选修课程的情况

    ```sql
    SELECT Student.*, SC.*
    FROM Student, SC
    WHERE Student.SNO = SC.SNO
    ```
*   自身连接：表格与自身连接，由于属性名相同，必须使用别名

    * 例：查询每一门课的间接先修课

    ```sql
    SELECT FIRST.Cno, SECOND.Cpno
    FROM C FIRST, C SECOND
    WHERE FIRST.Cpno = SECOND.Cno
    ```
* 外连接：保留悬浮元组，空值填充 NULL
    * 左外连接：`FROM <table_name> LEFT OUT JOIN <table_name> ON <condition>`
    * 右外连接：`FROM <table_name> RIGHT OUT JOIN <table_name> ON <condition>`
    * 这里写了`<condition>`，就不用`WHERE`了
* 多表连接：两个以上的表进行连接

### 嵌套查询

* 嵌套查询：在一个查询中嵌套另一个查询

```sql
SELECT <column_name>, ...
FROM <table_name>
WHERE <column_name> IN | EXISTS | ANY | ALL (
  SELECT <column_name> 
  FROM <table_name> 
  WHERE <condition>
  )
```

* 上层：父查询，下层：子查询
* 子查询不能使用`ORDER BY`
* 嵌套查询可以通过连接替代：谨慎使用嵌套查询
* 若确定内存查询返回单个值，可以使用比较运算符代替`IN`
* `ANY`：子查询返回的值中有一个符合条件即可
* `ALL`：子查询返回的值中所有符合条件
* 可尝试将`ANY`和`ALL`替换为聚集函数，提升性能
* `EXISTS`：子查询返回的结果集非空
    * `EXISTS`和`NOT EXISTS`只能用于子查询
    * `EXISTS`：子查询返回的结果集非空
    * `NOT EXISTS`：子查询返回的结果集为空
*   实现 $$\forall$$：使用两次 `NOT EXISTS`，$$(\forall x) P \equiv \neg((\exists x) \neg P)$$，都符合条件=不存在不符合条件的元组

    * 例：查询选修了所有课程的学生

    ```sql
    SELECT SNO
    FROM STUDENT S
    WHERE NOT EXISTS (
      SELECT Cno
      FROM C
      WHERE NOT EXISTS (
        SELECT Cno
        FROM SC
        WHERE SC.SNO = S.SNO AND SC.Cno = C.Cno
      )
    )
    ```
*   实现蕴含：$$P \Rightarrow Q \equiv \neg P \lor Q$$

    * 例：查询了至少选修了学生 201215122 选修的全部课程的学生号码
    * $$p$$：201215122 选修了课程 y
    * $$q$$：学生 x 选修了课程 y
    * $$\forall y (p \Rightarrow q)$$
    * $$\neg \exists y (p \land \neg q)$$

    ```sql
    SELECT DISTINCT SNO
    FROM SC S1
    WHERE NOT EXISTS ( -- 不存在有课程，在 201215122 选的同时，不存在其他人选了这门课 -> 对于每一门 201215122 选的课，筛选出来的人都选了 (描述的主语是 `SELECT` 后的结果)
      SELECT CNO
      FROM SC S2
      WHERE S2.SNO = '201215122'
      AND NOT EXISTS ( -- 不存在有 S3(S1) 选了 201215122 选的课
        SELECT CNO
        FROM SC S3
        WHERE S3.SNO = S1.SNO AND S3.CNO = S2.CNO
      )
    )
    ```

#### 嵌套查询求解方法

* 不相关子查询
    * 子查询的结果不依赖于父查询
    * 从内到外逐层处理
* 相关子查询
    * 子查询的结果依赖于父查询
    * 逐个选取外层表的元组，处理内层查询
    * 返回真保留，否则舍弃

### 集合查询

* `SELECT xxx op SELECT yyy`
* `UNION`：并集，默认去重
    * `UNION ALL`：并集，保留重复值
* `INTERSECT`：交集
* `EXCEPT`：差集
* 参与集合操作的查询结果必须列数相同，数据类型相同

### 基于派生表的查询

* `FROM (SELECT ...) AS <alias_name>`：在`FROM`中创建子查询

## SQL 数据插入

### 插入元组

```sql
INSERT INTO <table_name> [<column_name>, ...]
VALUES (<value>, ...)
```

* 属性列的顺序可以和表中定义的顺序不一致
* 未指定属性列时默认插入完整的元组，顺序按照表中顺序
* 未指定属性列时，未指定的列取空值
* `VALUES`中值的个数和类型必须和表中一致

#### 插入查询结果

```sql
INSERT INTO <table_name> [<column_name>, ...]
SELECT <column_name>, ...
FROM <table_name> [WHERE <condition>]
```

* `SELECT`中列数和类型必须和表中一致

## SQL 数据更新

```sql
UPDATE <table_name>
SET <column_name> = <value>, ...
WHERE <condition>
```

* `SET`中列数和类型必须和表中一致
* 若省略`WHERE`，则更新所有元组
* 关系数据库管理系统执行修改语句时，会检查修改操作是否破坏表上已定义的完整性规则
    * 实体完整性
    * 参照完整性
    * 用户定义的完整性：`NOT NULL`，`UNIQUE`，值域

## SQL 数据删除

```sql
DELETE FROM <table_name>
WHERE <condition>
```

* 若未指定`WHERE`，则删除所有元组，保留表的定义

## 空值

* 判断：`IS NULL`，`IS NOT NULL`

### 产生条件

* 应该有值，但是不知道具体值
* 不应该有值
* 因为某种原因不便于填写：~~性别类型是`BOOLEAN`，但是用户是小男娘~~

### 空值的约束条件

* `NOT NULL`：不允许空值
* `UNIQUE`：不允许重复值
* 码属性不能为空

### 空值的计算

* `NULL`参与算术计算时，结果为`NULL`
* `NULL`参与比较时，结果为`UNKNOWN`
* 含有`UNKNOWN`的逻辑运算:`TRUE` > `UNKNOWN` > `FALSE`
    * `NOT UNKNOWN`：`UNKNOWN`
    * `AND`：取“小”的
    * `OR`：取“大”的

## 视图

* 视图：从一个或多个基本表（或视图）导出的表
* 只存放定义，不重复存储数据
* 查询的数据随基本表的变化而变化
* 作用
    * 封装不同表的复杂性，简化用户操作
    * 为不同用户提供看待数据的不同角度
    * 便于重构底层数据库，无需更改用户的外模式
    * 安全防护：权限设置
    * 适当的利用视图可以更清晰的表达查询

### 建立视图

```sql
CREATE VIEW <view_name> [<column_name>, ...]
AS <query>
[WITH CHECK OPTION]
```

* `<query>`：任意查询语句 `SELECT ... FROM ... WHERE ...`
* `WITH CHECK OPTION`：检查视图的完整性约束，视图的插入、删除、更新操作必须满足视图定义的谓词条件（`WHERE`条件）
* 列名
    * 全部省略：视图的列为查询所得的全部字段
    * 明确指定：
        * 某个目标列是聚集函数或列表达式​
        * 多表连接时选出了几个同名列作为视图的字段​
        * 需要在视图中为某个列启用新的更合适的名字
* 行列子集视图：从单个基本表导出，只去掉某些行列，保留主码

### 删除视图

```sql
DROP VIEW <view_name> [CASCADE]
```

* `CASCADE`：删除视图的同时删除该视图导出的视图

### 查询视图

* 用户命令：和查询表相同
* 系统实现
    1. 进行有效性检查
    2. 转化为等价的对基本表的查询
    3. 执行修正后的查询
* 部分情况下无法正常转换：`GROUP BY`等

### 更新视图

```sql
UPDATE <view_name>
SET <column_name> = <value>, ...
WHERE <condition>
```

* 不可更新视图：对视图的更新无法有意义地转换为对基本表的更新
* 不可更新视图上定义的视图也不可更新

# 04-数据库安全性

## 存取控制

* 定义用户权限，将用户权限登记至数据字典中
* 用户发出存取请求时检查合法权限
* DBMS 的存取控制子系统：用户权限定义 + 合法权检查机制

### Discretionary Access Control (DAC)

* 用户对不同对象拥有不同的存取权限
* 不同用户对同对象的存取权限不同
* 用户可以将权限授予其他用户或收回权限：SQL 中的 `GRANT` `REVOKE`
* 缺点：数据本身无安全性标记，可能存在数据的泄露

### Mandatory Access Control (MAC)

* 数据对象被标以密级
* 用户被授予许可证
* 只有拥有合法许可证的用户才能访问数据
* 用户无法直接感知/进行控制
* 实体分类
    * 主体：系统中的活动实体，实际用户、进程
    * 客体：系统中的被动实体，文件、基本表、索引、视图
* 敏感度标记：Top Secret>=Secret>=Confidential>=Public
    * 主体的敏感度标记：许可证级别
    * 客体的敏感度标记：密级
* 控制规则
    * 读：主体的敏感度标记 >= 客体的敏感度标记，低级别的用户不能读高级别的对象，以防高级别数据泄漏
    * 写：主体的敏感度标记 <= 客体的敏感度标记，高级别的用户不能写低级别的对象，以防高级别数据泄漏
* 实现 MAC 前需要先实现 DAC

## SQL 中的授权机制

* 授权：定义用户的存取权限 `GRANT` `REVOKE`
* 用户权限：数据库对象 + 操作类型

### 用户权限

* 数据库管理员
    * 拥有所有对象的所有权限
    * 根据实际情况不同的权限授予不同的用户
* 用户
    * 拥有自己建立的对象的全部操作权限
    * 可以使用 `GRANT` 将权限授予其他用户
* 被授权的用户
    * 若拥有继续授权的许可，则可以将权限授予其他用户

### 授权语句

#### GRANT

```sql
GRANT <privilege> [, <privilege>...]
ON <object type> <object name> [, <object type> <object name>...]
TO <user> [, <user>...]
[WITH GRANT OPTION]
```

* `privilege`：权限
    * 数据库模式：`CREATE SCHEMA` `CREATE TABLE` `CREATE VIEW` `CREATE INDEX` `ALTER TABLE`
    * 基本表：`SELECT` `INSERT` `UPDATE` `DELETE` `REFERENCES` `ALL PRIVILEGES`
    * 属性列：`SELECT` `INSERT` `UPDATE` `REFERENCES` `ALL PRIVILEGES`
* 可发出 `GRANT` 的用户
    * 数据库管理员
    * 数据库对象创建者
    * 拥有权限的用户
* 接受权限的用户
    * 一个/多个具体用户
    * `PUBLIC`：所有用户
* `WITH GRANT OPTION`：被授权的用户可以将权限授予其他用户
* 不允许循环授权
* 对属性列授权时必须指出列名如`UPDATE(col1, col2)`

#### REVOKE

```sql
REVOKE <privilege> [, <privilege>...]
ON <object type> <object name> [, <object type> <object name>...]
FROM <user> [, <user>...]
[CASCADE|RESTRICT]
```

* `CASCADE`：删除所有引用该对象的权限
    * 若该对象从其他对象获得该权限，则不删除

#### 创建数据库模式的权限

* 在创建用户时实现

```sql
CREATE USER <user> [IDENTIFIED BY <password>]
[WITH] [DBA|RESOURCE|CONNECT]
```

* `DBA`：拥有所有权限
* `RESOURCE`：可创建基本表、视图，不可创建模式、新用户
* `CONNECT`：只可连接数据库

#### 角色

* 角色权限的集合

```sql
CREATE ROLE <role name>
-- 为角色授权
GRANT <privilege> [, <privilege>...]
ON <object type> <object name> [, <object type> <object name>...]
TO <role name>
-- 授权给其他角色/用户
GRANT <role name> [, <role name>...]
TO <user> [, <user>...]
[WITH ADMIN OPTION]
-- `REVOKE` 语法相同，省略
```

* `WITH ADMIN OPTION`：被授权的用户可以将权限授予其他用户
* `REVOKE` 的执行者
    * 角色创建者
    * 拥有在角色上 `ADMIN OPTION`的用户

## 视图

* 另一种管理权限的实现
* 语法和基本表相同，相见第三章笔记

## 审计

* 将用户对 DB 的操作记录在日志上以供审计
* 审计事件
    * 服务器事件
    * 系统权限
    * 语句事件
    * 模式对象事件
* 审计功能：规则、报表、管理、查询视图
* 审计级别
    * 用户级审计：任何用户均可设置，用户自己创建的对象
    * 系统级审计：只能由管理员设置，全局性

```sql
AUDIT <privilege> [, <privilege>...] ON <object type> <object name> 
NOAUDIT <privilege> [, <privilege>...] ON <object type> <object name>
```

## 加密

* 储存加密
    * 透明存储加密：写入时加密，读出时解密
    * 非透明存储加密
* 传输加密
    * 链路加密
    * 端到端加密

## 其他安全性保护

* 推理控制：避免利用能够访问的数据推知更高级的数据
* 隐蔽信道：间接数据传递
* 数据隐私保护

# 05-数据库完整性

## 基本概念

* 数据库完整性
    * 数据的正确性：数据符合现实语义
    * 数据的相容性：同一对象在不同表中表示符合逻辑
* 完整性机制
    * 定义完整性约束条件的机制
    * 完整性检查的方法
    * 违约处理

{% hint style="info" %}
- 完整性：防范不合语义、不正确的数据
- 安全性：防范非法用户和非法操作
  {% endhint %}

## 实体完整性（定义主键）

* 单个属性为主键：可在列/表级定义

```sql
-- 在列级定义
CREATE TABLE student (
    sno INT PRIMARY KEY,
    sname VARCHAR(20),
    sage INT
);
-- 在表级定义
CREATE TABLE student (
    sno INT,
    sname VARCHAR(20),
    sage INT,
    PRIMARY KEY (sno)
);
```

* 多个属性为主键：只能在表级定义

```sql
CREATE TABLE student (
    sno INT,
    sname VARCHAR(20),
    sage INT,
    PRIMARY KEY (sno, sname)
);
```

### 检查实体完整性

* 检查
    * 主键是否唯一
    * 主键的各个属性是否非空
* 检查手段
    * 全表遍历：$$O(n)$$
    * B+ 树索引：$$O(\log n)$$

## 参照完整性（定义外键）

* `FOREIGN KEY`：定义外键的列
* `REFERENCES`：定义外键引用的表和列（必须是唯一的）

```sql
CREATE TABLE student (
    sno INT PRIMARY KEY,
    sname VARCHAR(20),
    sage INT
);
CREATE TABLE course (
    cno INT PRIMARY KEY,
    cname VARCHAR(20),
    sno INT,
    FOREIGN KEY (sno) REFERENCES student(sno)
);
```

### 检查参照完整性

| 操作         | 触发条件                    | 触发操作         |
| ---------- | ----------------------- | ------------ |
| 插入违反外键约束   | 插入新记录时，外键值在被引用的表中不存在    | 拒绝插入         |
| 更新违反外键约束   | 更新外键值时，外键值在被引用的表中不存在    | 拒绝更新         |
| 删除被引用的主键记录 | 删除主键记录时，引用表中仍有使用该外键值的记录 | 拒绝删除/级联删除/置空 |
| 更新被引用的主键记录 | 更新主键记录时，引用表中仍有使用该外键值的记录 | 拒绝更新/级联更新/置空 |

#### 违约处理语法

* `NO ACTION`：拒绝操作，默认
* `CASCADE`：级联操作，删除/更新主键时，删除/更新引用表中所有外键值相同的记录
* `SET NULL`：设置为空

```sql
...
    FOREIGN KEY (sno) REFERENCES student(sno) 
      ON UPDATE CASCADE
      ON DELETE SET NULL
...
```

## 用户定义的完整性（语义要求）

* 单个属性的取值条件
    * `UNIQUE`：唯一性约束
    * `NOT NULL`：非空约束
    * `CHECK`：取值范围约束
* 元组的取值条件：属性之间存在依赖，需要约束

```sql
CREATE TABLE student(
    sno UNIQUE,
    sname NOT NULL,
    ssex CHAR(1) CHECK (ssex IN ('M', 'F')),
    CHECK(ssex='F' OR sname NOT LIKE 'Ms.%'),
)
```

## 完整性约束命名子句

* `CONSTRAINT`：为约束规则显式命名，便于后续更改/删除
* 不用也能正常定义规则，但是为修改和维护带来不便

```sql
CREATE TABLE student(
    sno INT,
    sname VARCHAR(20) CONSTRAINT name_check NOT NULL,
    ssex CHAR(1) CONSTRAINT sex_check CHECK (ssex IN ('M', 'F')),
    CONSTRAINT name_sex_check CHECK(ssex='F' OR sname NOT LIKE 'Ms.%'),
);
-- 修改约束
ALTER TABLE student
    DROP CONSTRAINT name_check;
ALTER TABLE student
    ADD CONSTRAINT name_check UNIQUE (sname);
```

## 断言

* 若断言为假，拒绝执行
* 性能开销较大

```sql
CREATE ASSERTION max_enrollment_check
    CHECK (60 >= (SELECT COUNT(*) 
      FROM course,sc 
      WHERE sc.cno = course.cno AND course.name='DB'));
```

## 触发器

* Event-Condition-Action：当特定事件发生，且满足触发条件时，激活触发器，执行定义的操作
* 保存在数据库服务器中
* 表的拥有者才可以在表上创建触发器
* 触发器名
    * 同一模式下必须唯一
    * 触发器名称和表名称必须在同一模式下
* 表名：触发器只能定义在基本表上
* 触发事件
    * `INSERT` `UPDATE` `DELETE`
    * `UPDATE OF <column_name>`：只在指定列上触发
* 激活顺序：`BEFORE`触发器、SQL 语句、`AFTER`触发器
* 执行频率
    * `FOR EACH ROW`：每行触发一次
    * `FOR EACH STATEMENT`：每个语句触发一次
* 动作：可以是
    * SQL 语句
    * PL/SQL 语句块
* 触发器的删除者必须有对应的权限

```sql
CREATE TRIGGER <trigger_name>
  {BEFORE | AFTER} <event> ON <table_name>
  REFERENCING {OLD | NEW} ROW AS <alias>
  FOR EACH {ROW|CONDITION}
  [WHEN <condition>] <action>
DROP TRIGGER <trigger_name> ON <table_name>;
```

```sql
CREATE TRIGGER Insert_Or_Update_Sal ​
BEFORE INSERT OR UPDATE ON Teacher  ​
REFERENCING NEW row AS newTuple​
FOR EACH ROW
  BEGIN​
    IF (newTuple.Job='教授') AND (newTuple.Sal < 4000) ​
      THEN newTuple.Sal :=4000;                ​
    END IF;​
  END;
-- 删除触发器
DROP TRIGGER Insert_Or_Update_Sal ON Teacher;
```

# 06-关系范式

## 基本定义

* 五元组$$R(U,D,DOM,F)$$
    * $$R$$：关系模式名
    * $$U$$：属性集
    * $$D$$：属性的域
    * $$DOM$$：$$U$$到$$D$$的映射
    * $$F$$：函数依赖集
* 可省略$$D$$，$$DOM$$，变为三元组$$R<U,F>$$
    * 数据库中$$D$$和$$DOM$$是明确的
* 当且仅当$$U$$上的关系$$R$$满足$$F$$时，$$r$$称为关系模式$$R<U,F>$$ 的一个关系（合法的关系）

## 数据依赖

### 函数依赖

* $$(X)\to Y$$，$$X$$函数确定于$$Y$$，$$Y$$函数依赖于$$X$$
    * $$X$$可以唯一确定$$Y$$，$$Y=f(X)$$
    * 不存在$$X$$的值相同而$$Y$$的值不同的情况
    * $$X$$是属性集
* $$X \to Y, Y \to X \Rightarrow X \leftrightarrow Y$$
* $$X \nrightarrow Y$$：$$Y$$不函数依赖于$$X$$
* $$R$$中的所有关系都要满足$$F$$中的所有函数依赖
* 函数依赖是语义范畴的概念
* 平凡/非平凡：$$Y$$是否是$$X$$的子集
    * 平凡的函数依赖：$$X \to Y$$，$$Y \subseteq X$$
    * 非平凡的函数依赖：$$X \to Y$$，$$Y \not\subseteq X$$
* 完全/部分函数依赖：$$X$$的子集能否唯一确定$$Y$$
    * 完全函数依赖：$$X \to Y$$，$$\forall Y \subset X$$，$$Y \nrightarrow Y$$，记作$$X \xrightarrow{F} Y$$
    * 部分函数依赖：$$X \to Y$$，$$\exists Z \subset X$$，$$Z \to Y$$，记作$$X \xrightarrow{P} Y$$
* 传递依赖：$$X \to Y, Y \to Z, Y \nrightarrow X, Z \nsubseteq Y$$，记作$$X \xrightarrow{传递} Z$$
    * 若$$X \to Y , Y \to Z, Y \to X$$，则$$Z$$直接依赖于$$X$$，不算传递函数依赖

> - 若 $$X$$ 和 $$Y$$ 是 1:1 映射关系，则 $$X \to Y$$ , $$Y \to X$$
    >   * 若 $$X$$ 和 $$Y$$ 是 1:N 映射关系，则 $$Y \to X$$
> - 若 $$X$$ 和 $$Y$$ 是 N:M 映射关系，则 不存在函数依赖

### 闭包

* $$X^+$$：$$X$$的闭包，$$X$$能唯一确定的属性集
* 生成方法：递归检查依赖，直到没有新的属性加入为止

### 多值依赖

* 某个属性同时决定两组不相关的信息，两组信息可以任意组合，产生冗余
* 设$$R(U)$$是属性集$$U$$上的一个关系模式。$$X,Y,Z$$是$$U$$的子集，并且$$Z=U-X-Y$$。关系模式$$R(U)$$中多值依赖 $$X\twoheadrightarrow Y$$ 成立，当且仅当对$$R(U)$$的任一关系$$r$$，给定的一对$$(x,z)$$值，有一组$$Y$$的值，这组值仅仅决定于$$x$$值而与$$z$$值无关。
* 平凡的多值依赖：$$Z=\emptyset$$
* 对称性：$$X \twoheadrightarrow Y \Rightarrow X \twoheadrightarrow Z,\quad \text{其中 } Z = U - X - Y$$
* 传递性：$$X \twoheadrightarrow Y,\ Y \twoheadrightarrow Z \Rightarrow X \twoheadrightarrow Z - Y$$
* 函数依赖是特例：$$X \rightarrow Y \Rightarrow X \twoheadrightarrow Y$$
* 并规则：$$X \twoheadrightarrow Y,\ X \twoheadrightarrow Z \Rightarrow X \twoheadrightarrow YZ$$
* 交规则：$$X \twoheadrightarrow Y,\ X \twoheadrightarrow Z \Rightarrow X \twoheadrightarrow Y \cap Z$$
* 差规则：$$X \twoheadrightarrow Y,\ X \twoheadrightarrow Z \Rightarrow X \twoheadrightarrow Y - Z,\ X \twoheadrightarrow Z - Y$$

## 码

* $$K$$ 为 $$R<U,F>$$ 的一个属性集
* 候选码：可唯一确定元组的属性集
    * $$K \xrightarrow{F} U$$，$$K$$是$$R$$的一个候选码（最小超码）
* 超码：在候选码的基础上加其他属性
    * $$K \xrightarrow{P} U$$，$$K$$是$$R$$的一个超码（候选码的超集）
* 若$$R$$有多个候选码，选一个作为主码
* 主属性：候选码中出现的属性
* 非主属性/非码属性：不包含在任意候选码中的属性
* 全码：整个属性组都是码，缺一不可
* 外码：关系模式中的属性集$$K$$并非候选码，但$$K$$在另一个关系模式中是候选码

## 范式

* 满足某一级别的关系模式的集合
* $$1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF \supset 5NF$$
* $$R \in nNF$$：$$R$$满足$$nNF$$的所有条件
* 规范化：低一级范式通过模式分解转换成高一级范式模式的集合

### 1NF

* 每个分量都是不可分的原子值，不能出现多个项$$Y=\{a_1,a_2\}$$的情况
* 关系数据库的基本要求
* 缺点
    * 数据冗余 & 更新异常：必须要更改所有的，以免数据不一致
    * 插入异常：插入一个元组时，必须要插入所有的属性值，无法仅插入部分属性值
    * 删除异常：删除某个元组后，可能会丢失仅依赖于该元组的其他信息
* 解决方法：分解成多个关系模式，用规范化理论消除不合适的数据依赖

### 2NF

* 非主属性必须**完全依赖**于候选码
* 消除部分依赖
* 表里属性都和候选码相关
* 改善：数据冗余、更新异常（但是仍然存在）

```
# 满足 1NF 不满足 2NF 的例子
表格 (A, B, C, D)
A -> C
(A, B) -> D
# 解决方案
表格1 (A, C)
A -> C
表格2 (A, B, D)
(A, B) -> D
```

### 3NF

* 消除传递依赖
* 关系模式中没有传递依赖，所有非主属性都直接依赖于候选码
* 表里属性都和候选码直接相关
* 改善：插入异常、删除异常（但是仍然存在）
* 若所有属性都是主属性，则满足 3NF

```
# 满足 2NF 不满足 3NF 的例子
表格 (A, B, C)
A -> B
B -> C
# 解决方案
表格1 (A, B)
A -> B
表格2 (B, C)
B -> C
```

### BCNF

* 除了候选码本身，不允许任何非候选码的属性集参与决定关系中的其他属性
* 所有非主属性都完全依赖于每个候选码
* 所有主属性的完全依赖于每个不包含他的候选码
* 没有任何属性完全函数依赖于非码的属性
* 彻底消除插入异常、删除异常

```
# 满足 3NF 不满足 BCNF 的例子
C -> B  
(A, B) -> C
```

### 4NF 5NF

略。

### 判断流程

> 感谢 [https://www.bilibili.com/video/av741922043/](https://www.bilibili.com/video/av741922043/)

1. 求候选码、主属性、非主属性
2. 所有函数依赖的左边都是超码 -> BCNF
3. 左边非超码的函数依赖的右边是主属性 -> 3NF
4. 任意候选码的真子集都无法推出非主属性 -> 2NF
5. 所有属性都是原子值 -> 1NF

# 07-数据库设计

## 概述

* 目标：满足用户的
    * 信息管理需求：在数据库中存储/管理的对象
    * 数据操作需求：增删查改，统计
* 特点
    * 三分技术、七分管理、十二分基础数据
    * 结构设计（数据库相关）和行为设计（应用相关）相结合

### 基本步骤

1. 需求分析：独立于 DBMS
2. 概念结构设计：对应概念模式
3. 逻辑结构设计：对应逻辑模式/外模式，和 DBMS 相关
4. 物理结构设计：对应内模式，和 DBMS 相关
5. 数据库实施
6. 数据库运行维护

## 需求分析

* 调查用户需求
    * 信息要求 -> 数据要求：数据库中信息的内容、性质
    * 处理要求：需要完成的处理功能、性能
    * 完整性、安全性要求
* 结构化分析方法
* 强调用户的参与

### 数据字典

* 关于数据库中数据的描述
* 和 DBMS 中的数据字典对应

#### 数据项

* 数据项名、数据项含义说明、别名
* 数据类型、长度、取值范围、取值含义
* 与其他数据项的逻辑关系定义了数据的完整性约束条件
* 数据项之间的联系
* 注：取值范围、与其他数据项的逻辑关系ding'ydingy

#### 数据结构

* 数据结构名、含义说明
* 组成：{数据项/数据结构}

#### 数据流

* 数据流名、说明
* 数据流来源、去向
* 组成：{数据结构}
* 平均流量、高峰期流量

#### 数据存储

* 数据存储名、说明、编号
* 输入数据流、输出数据流
* 组成：{数据结构}
* 数据量
* 存取频度
* 存取方式：批处理/联机处理；检索/更新；顺序/随机

#### 处理过程

* 处理或成名，说明
* 输入：{数据流}
* 输出：{数据流}
* 处理：{简要说明}
    * 功能
    * 处理要求：数据量、事务数量、响应时间

## 概念模型

### 实体间联系

* 一对一 `1:1`：对于 A 中的实体，B 中没有/至多一个实体与之对应，反之亦然
* 一对多 `1:n`：对于 A 中的实体，B 中有零个/一个/多个实体与之对应，对于 B 中的实体，A 中有零个/一个实体与之对应
* 多对多 `m:n`：对于 A 中的实体，B 中有零个/一个/多个实体与之对应，反之亦然
* 多个实体间也围绕联系名，存在不同的联系
* 同一实体集中的不同实体也有联系：职工&领导关系（职工领导职工，1对多）

### E-R 图

* 实体型 + 实体属性 + 实体间联系
* 联系的度：参与联系的实体集的个数

#### 绘图规则

* 实体型：矩形
* 属性：椭圆形
* 联系：菱形
    * 通过无向边连接实体和联系，写上联系类型
    * 联系可以具有属性

<figure><img src="../../.gitbook/assets/database-07-er-graph.png" alt=""><figcaption><p>简单的 ER 图</p></figcaption></figure>

#### Is-A 关系

* 实体间的继承关系：子类继承父类所有属性，子类也可有自己的属性
* 使用三角形表示分类属性
* 可重叠约束：父类中的实体可以属于多个子类
* 不相交约束：父类中的实体最多属于一个子类
    * 在三角形中增加 x 表示
* 部分特化：父类中的实体可以不属于任何子类
* 完全特化：父类中的实体必须属于至少一个子类
    * 连线使用双线表示

#### 基数约束

* 对一对一，一对多，多对多的细化
* 表示上下限，`*`表示无穷大
* A 必须对应 xx-yy 个 B（xx-yy 读靠近 B 的一端）
* 强制参与约束：`min=1`
* 非强制参与约束：`min=0`

#### Part-Of 关系

* 某个实体型是另一个实体型的组成部分
* 非独占 Part-Of：整体被破坏后，另一部分实体仍然存在（对应非强制参与）
* 独占 Part-Of：整体被破坏后，另一部分实体也不存在
* 弱实体型：本身存在依赖于其他实体型的存在
    * 在数据库中需要其他实体的主键
    * 通过双菱形表示识别联系
    * 通过双矩形表示弱实体型
* 强实体型：本身存在不依赖于其他实体型的存在

## 概念结构设计

* 自顶向下：先定义全局框架，逐步细化
* 自底向上：先定义局部概念结构，随后集成为全局概念结构
* 逐步扩张：先定义最重要的核心概念结构，随后向外扩充，逐步生成其他概念结构
* 混合策略：自顶向下需求分析+自底向上设计概念结构

### 实体 & 属性

* 能作为属性的尽量作为属性
* 属性是不可分的数据项
* 属性不能包含其他属性
* 属性不能与其他实体具有联系
* 若不满足以上条件，则考虑将其作为实体

### 集成 ER 图

* 合并：解决分图间的冲突
    * 属性冲突：类型、取值、单位冲突
    * 命名冲突：同名异义、异名同义
    * 结构冲突
        * 同一对象在不同应用中有不同抽象：在一处是实体，另一处是属性
        * 同一实体在不同 E-R 图中包含的属性个数、属性排列次序不同
        * 实体间的联系在不同 E-R 图中为不同类型
* 修改、重构：消除不必要的冗余
    * 规范化理论：将联系变为函数依赖集$$F_L$$，求$$F_L$$的最小依赖$$G_L$$，考查$$D=F_L-G_L$$中的依赖是否冗余
    * 冗余的关系一定在$$D$$中，$$D$$中的关系不一定冗余
    * 当实体之间存在多种联系时，需要加以区分

## 逻辑结构设计

* 把 E-R 图用的概念结构转化为逻辑结构

### 转换规则

* 实体型 -> 关系模式
    * 实体的属性 -> 关系的属性
    * 实体的码 -> 关系的码
* 1:1 联系
    * -> 独立的关系模式（新开一张表）
    * 和某一端实体对应的关系模式合并（作为某一端的属性）
* 1:n 联系
    * -> 独立的关系模式
    * -> 和n端的对应关系模式合并
* m:n 联系 -> 独立的关系模式
* 多元联系（三个及以上实体间的联系）-> 独立的关系模式
* 具有相同码的关系模式可合并
* 每个实体需加入编号作为主键
* 需根据题意加入合适的信息：类别、数量……

### 垂直/水平分解

* 水平分解：把关系的元组分为若干自子集合，定义每个子集合为一个子关系（按照行拆分表）
    * 使用场景：部分元组较为常用，而其他元组不常用
* 垂直分解：把关系的属性分为若干子集，定义每个子集为一个子关系（按照列拆分表）
    * 优点：提升某些事务效率
    * 缺点：部分事务需要连接操作，降低效率
    * 适用场景：某些属性经常一起使用，且其他属性不经常使用，取决于分解后的总效率是否提高

## 物理结构设计

* 为关系模式设计存取方法
* 设计关系、索引等数据库文件的物理存储结构

### B+ 树索引

* 确定
    * 对哪些列建立索引
    * 哪些列建立组合索引
    * 哪些列设计为唯一索引
* 原则
    * 属性经常在查询条件中出现
    * 属性经常作为`MIN`、`MAX`、`SUM`等函数的参数
    * 属性经常在连接条件中出现
* 索引过多会带来开销

### Hash

* 属性经常出现在等值连接、等值比较中，且
    * 关系大小可预知，不变
    * 或 关系大小动态改变，但选用的数据库管理系统提供了动态 Hash 存取方法

### Cluster 聚簇

* 原理
    * 独立聚簇：将某属性的值相同的元组集中存放在连续的物理块中，减少磁盘 I/O
    * 组合聚簇：把多个连接的元组按连接属性值聚集存放，加速连接查询
* 一个数据库可以建立多个聚簇，一个关系只能加入一个聚簇
* 设计候选聚簇
    * 单个关系独立聚簇
    * 经常进行连接操作的多个关系：建立组合聚簇
    * 经常进行等值比较的关系的属性
    * 重复率高的属性
* 检查聚簇中的关系，取消不必要的关系
    * 经常进行权标扫描的关系
    * 更新操作远多于连接操作的关系
    * 重复出现的关系：原则开销最小的
* 局限
    * 只能提高特定引用的性能：`ORDER BY`、`GROUP BY`、`UNION`、`DISTINCT`
    * 建立维护开销大

### 确定数据库的存储结构

* 确定关系、索引、聚簇、日志、备份

#### 影响因素

* 硬件环境
* 应用需求
    * 存取时间
    * 存储空间利用率
    * 维护代价

#### 具体内容

* 确定数据存放位置
    * 将易变部分和稳定部分分开存放
    * 将高频存取和低频存取分开存放
    * 将大的表放在多个磁盘
    * 将日志文件和数据库对象分开存放
* 确定系统配置：基于缺省值设定
* 评价物理结构

## 数据库实施维护

* 数据载入：人工/计算机辅助
* 应用程序调试
* 数据试运行
    * 功能测试
    * 性能测试
    * 数据分期入库：逐步增加数据量
    * 数据库的转储和恢复

### 维护

* 数据库的转储和恢复​：定期备份数据库+日志，在故障时将数据库恢复到可用状态
* 数据库的安全性、完整性控制​：权限&完整性约束
* 数据库性能的监督、分析和改进​：使用监测工具监测性能
* 数据库的重组织与重构造​
    * 重组织：在运行后期，数据库的物理结构会发生变化，导致性能下降
    * 重构造：实体间的联系发生变化，调整模式/内模式，可调整程度有限

# 08-事务 存储

## 事务

* 事务：用户定义的不可分割的一组操作序列
* ACID 特性
    * 原子性 Atomicity：要么全做，要么全不做
    * 一致性 Consistency：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态（完整性约束没有被破坏）
    * 隔离性 Isolation：并发执行的事务之间互不干扰
    * 持久性 Durability：事务一旦提交，对数据库的修改是永久性的
* 破坏事务 ACID 特性的因素
    * 多个事务并行
    * 事务在运行中被强行终止

```sql
BEGIN TRANSACTION
-- 事务开始
-- 事务中的操作
  SQL 1
  SQL 2
-- ...
COMMIT
-- 提交事务
ROLLBACK
-- 回滚事务
```

## 故障 & 恢复

* 数据库本身被破坏
* 数据库未破坏，数据不正确

### 分类

* 事务故障：事务在正常终止点前被终止
* 系统故障：操作系统/硬件层面的停止运转
* 介质故障：硬件层面
* 计算机病毒
* 恢复：利用冗余数据重建数据库

## 数据转储 & 日志

* 转储：定期将数据库完整复制到其他介质
* 恢复到故障发生时的状态需重新运行转储以后的所有更新事务

### 转储方法

* 静态转储：在无事务运行时转储
    * 优点：数据一致，实现简单
    * 缺点：降低数据库可用性
* 动态转储：在有事务运行时转储
    * 优点：不影响数据库可用性
    * 缺点：数据不一致，恢复时需要和更改日志结合
* 海量转储：全量
* 增量转储：增量

### 日志

* 记录事务对数据库的更新操作的文件
* 格式
    * 以记录为单位
    * 以数据块为单位
* 用途：事务故障、系统故障、介质故障恢复
* 登记日志原则
    * 登记次序需严格按照事务的执行顺序
    * 先登记后执行（多一次无效的撤销不会影响数据正确性）

## 恢复策略

* 事务故障：恢复子系统根据日志**自动**撤销对数据库的更改
    * 反向扫描日志文件，执行逆操作
* 系统故障
    * 回滚未完成的事务：只有`BEGIN`，没有`COMMIT`（做题中已经正常状态下到`ROLLBACK`的事务也要计入在故障时需回滚事务中）
    * 重做已提交的事务：有`BEGIN`和`COMMIT`
    * 正向扫描文件
    * 自动完成
* 介质故障：重装数据库、重做已完成的事务
    * 需人工介入
    * 随后重做已提交的事务

### 检查点

* 恢复的问题：搜索日志和重做浪费大量时间
* 检查点：在日志文件中增加检查点、重新开始文件，动态维护日志
    * 检查点记录：建立时刻正在执行的事务清单，事务最近一个日志记录的地址
    * 重新开始文件：“检查点记录”在日志文件中的地址
* 维护日志文件步骤：周期性建立检查点，保存数据库状态
    1. 将日志缓冲区中的日志写入日志文件
    2. 在日志文件中增加检查点记录
    3. 将数据缓冲区的数据记录写入数据库
    4. 将 检查点记录 在日志文件中的地址写入 重新开始文件
* 建立检查点：定期/不定期
* 恢复策略
    * 在检查点之前结束：无需重做
    * 在检查点建立-故障之间结束：重做
    * 在故障时仍未结束：回滚
* 恢复步骤
    1. 从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由此找到最后一个检查点记录
    2. 将所有正在执行的事务放入 `ACTIVE` 队列，将 `ACTIVE` 队列中的事务放入 `UNDO` 队列
    3. 从检查点记录开始，向后扫描日志文件
        * 若有新事务：加入 `UNDO` 队列
        * 若有已提交事务：移入 `REDO` 队列
    4. `UNDO` 队列中的事务进行撤销，`REDO` 队列中的事务进行重做

## 数据库镜像

* 故障时：无需关闭系统、重装副本，由 DBMS 自动恢复
* 没有故障时可并发操作：读并发，写加锁
* 实际中只对关键数据/日志镜像

# 09-并发

* 多用户数据库系统：多个用户同时使用
* 多事务执行方式
    * 串行
    * 交叉并发：单处理器，本质上是串行执行
    * 同时并发：多处理器，多个事务同时执行
* 并发控制
    * 调度并发操作
    * 保证事务的隔离性
    * 保证数据库的一致性
* 数据不一致性：并发操作破坏了事务的隔离性
    * 丢失修改：A 写后 B 写，导致 A 写的内容**被覆盖**
    * 不可重复读：A 读后 B 写后 A 读，当 A 两次读取的**数据不一致**（可能为增/改/删）
    * 读脏数据：A 写后 B 读后 A 撤销写，B 读取了**撤销前的数据**，产生错误

## 封锁

* 封锁：对数据项的访问加锁，防止其他事务访问

### 种类

| 类型 | 别称     | 上锁者权限   | 他人权限                | 作用            |
| -- | ------ | ------- | ------------------- | ------------- |
| X锁 | 排他锁/写锁 | 独占，可读可写 | 无                   | 写者为避免他人读取错误数据 |
| S锁 | 共享锁/读锁 | 可读      | 可读（只能上 S 锁，不能上 X 锁） | 读者为避免他人修改数据   |

| T1\T2 | X | S | - |
| ----- | - | - | - |
| X     | N | N | Y |
| S     | N | Y | Y |
| -     | Y | Y | Y |

### 常用符号

* `Ri(X)`：事务`Ti`对数据项`X`的读操作
* `Wi(X)`：事务`Ti`对数据项`X`的写操作
* `Slock X`：对数据项`X`加 S 锁
* `Xlock X`：对数据项`X`加 X 锁
* `Unlock X`：对数据项`X`解锁

### 封锁协议

| 类型     | 写            | 读            | 丢失修改 | 读脏数据 | 不可重复读 |
| ------ | ------------ | ------------ | ---- | ---- | ----- |
| 一级封锁协议 | 上 X 锁，事务结束释放 | 不上锁          | Y    | N    | N     |
| 二级封锁协议 | 上 X 锁，事务结束释放 | 上 S 锁，读取后释放  | Y    | Y    | N     |
| 三级封锁协议 | 上 X 锁，事务结束释放 | 上 S 锁，事务结束释放 | Y    | Y    | Y     |

* X 锁的释放时机为事务结束，包含了 COMMIT 和 ROLLBACK

### 上锁带来的问题

* 活锁：系统先满足后来事务的请求，先来的事务一直在等待锁，无法继续执行
    * 采用先来先服务的方式
* 死锁：两个或多个事务互相等待对方释放锁，导致无法继续执行
    * 解除死锁：撤销处理代价最小的事务并释放锁，使其他事务继续执行

#### 检测死锁

> OS 中预防死锁的方式不适合数据库的特点

* 一次封锁法：事务将所需的数据一次性上锁
    * 牺牲并发度
* 顺序封锁法：定义上锁顺序，所有事务的上锁顺序一致
    * 实现复杂
* 超时法：事务等待锁的时间超过一定阈值则放弃
    * 实现简单
    * 可能误判
* 等待图法：间歇性生成事务等待图，如果存在回路则死锁
    * 节点：事务
    * 边：事务之间的等待关系

## 调度

* 可串行化调度：多事务并发后的结果和事务按某一顺序串行执行的结果一致
    * 并发调度当且仅当其为可串行化时才是正确调度

> 事务T1：读B；A=B+1；写回A&#x20;
>
> 事务T2：读A；B=A+1；写回B
>
> A,B 初始值均为 2
>
> 并行调度后，若(A,B)=(3,4) 或 (4,3)，则都是正确的调度结果

### 冲突可串行化

* 目标：判定调度是否可串行化
* 冲突操作
    * `Ri(X)` 和 `Wj(X)` 冲突
    * `Wi(X)` 和 `Wj(X)` 冲突
* 不能交换的操作：
    * 同一事务的两个操作
    * 不同事务的冲突操作
* 若调度`Sc`在保证冲突操作次序不变的情况下，交换事务不冲突操作的次序，得到串行的调度`Sc'`，则`Sc` 是冲突可串行化的
* 冲突可串行化 -> 可串行化（仅为充分条件）
    * 不满足冲突可串行化的调度不一定不可串行化

> `T1 = W1(Y) W1(X)`&#x20;
>
> `T2 = W2(Y) W2(X)`&#x20;
>
> `T3 = W3(X)`&#x20;
>
> `L1 = T1 T2 T3 = W1(Y) W1(X) W2(Y) W2(X) W3(X)` 是串行调度&#x20;
>
> `L2 = W1(Y) W2(Y) W2(X) W1(X) W3(X)` 虽然不是冲突可串行化的调度，但是结果和`L1`一致，是可串行化的调度
>
> `L3 = W1(Y) W2(Y) W1(X) W2(X) W3(X)` 是冲突可串行化的调度，因此也是可串行化调度&#x20;

### 两段锁协议

* 目标：实现调度的可串行性
* 实现步骤
    1. 扩展阶段：在需要用数据前，先上锁
    2. 收缩阶段：释放锁，开始释放锁后不能再上锁
* 两段锁协议 -> 可串行化（仅为充分条件）
    * 不满足两段锁协议的调度不一定不可串行化
* 和一次封锁法的差别：
    * 一次封锁法必须一次性对所有所需数据上锁
    * 两端锁协议更宽松，可上锁后对数据进行操作，随后继续上锁，只需保证上锁和释放过程不交叉
    * 因此两段锁协议的事务可能会发生死锁

## 封锁粒度

* 封锁力度：上锁对象的大小
    * 逻辑单元：属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库
    * 物理单元：页（数据页/索引页）、物理记录
* Tradeoff：并发度 vs 封锁开销
    * 粒度越小，封锁开销越大，并发度越高
    * 粒度越大，封锁开销越小，并发度越低

### 多粒度封锁

* 多粒度封锁：根据事务所需数据的粒度，动态调整封锁粒度
* 多粒度树：以树表示多级封锁粒度
    * 根节点为整个数据库
    * 子节点为最小的数据粒度
    * 当父节点上锁时（显式上锁），子节点自动上锁（隐式上锁）
* 实现：系统检查封锁冲突时需同时检查上锁节点的父节点、上锁节点本身和上锁节点的子节点

#### 意向锁

* 目的：提高加锁时系统的检查效率
* 意向锁：当子节点加基本锁时，须对所有父节点加意向锁
    * IS（意向共享锁）：子节点上 S 锁时，父节点上 IS 锁
    * IX（意向排他锁）：子节点上 X 锁时，父节点上 IX 锁
    * SIX（共享意向排他锁）：同时对对象上 S 锁和 IX 锁

| T1\T2 | S | X | IS | IX | SIX | - |
| ----- | - | - | -- | -- | --- | - |
| S     | Y | N | Y  | N  | N   | Y |
| X     | N | N | N  | N  | N   | Y |
| IS    | Y | N | Y  | Y  | Y   | Y |
| IX    | N | N | Y  | Y  | N   | Y |
| SIX   | N | N | Y  | N  | N   | Y |
| -     | Y | Y | Y  | Y  | Y   | Y |

* 锁的强度：X > SIX > (S, IX) > IS > 无锁
    * 对其他锁的排斥程度
    * 以强锁代替弱锁是安全的
* 具有意向锁的多粒度封锁方法
    * 申请封锁：从上向下对数据库加意向锁，检查是否存在不相容的锁
    * 释放封锁：从下向上
    * 好处：无需检查对象的子对象的锁状态，减少开销

# 90-期末复习

## 题型

* 单选 2%\*15
* 简答 8%\*5
* 问答 10%\*3
* 作业都需要会

## 背诵

> 以下为需要完整背诵的概念

### 关系型数据库

#### 人工、文件、数据库的场景

* 人工：“挥发性”计算，无需持久化保存，无共享，冗余度大，无结构
* 文件：“持久性”计算，共享性差，冗余度大，记录内有结构，整体无结构，独立性差
* 数据库：“共享性”计算

#### 三个模型

| 类别   | 概述                | 应用场景   |
| ---- | ----------------- | ------ |
| 概念模型 | 按用户观点对数据和信息建模     | 数据库设计  |
| 逻辑模型 | 按计算机系统观点对数据和信息建模  | DBMS实现 |
| 物理模型 | 描述数据在系统内部的表示和存取方法 | 数据库实现  |

#### 三级模式、两重映射

* 三级模式
    * 外模式：数据库用户使用的局部数据的逻辑结构和特征描述
    * 模式：数据库中全体数据的逻辑结构和特征描述
    * 内模式：数据物理结构和存储方式的描述
* 两重映射
    * 外模式/模式映像：定义外模式和模式的对应关系，保证数据逻辑独立性
    * 模式/内模式映像：定义模式和内模式的对应关系，保证数据物理独立性

### 安全

#### 自主存取控制

* 用户对不同对象拥有不同的存取权限
* 不同用户对同对象的存取权限不同
* 用户可以将权限授予其他用户或收回权限
    * `GRANT privilege ON sth TO sb`
    * `REVOKE privilege ON sth FROM sb`&#x20;
    * 为所有用户授权/收回时，使用 `PUBLIC`
* 缺点：数据本身无安全性标记，可能存在数据的“无意泄露”

#### 强制存取控制

* 数据对象被标以密级
* 用户被授予许可证
* 只有拥有合法许可证的用户才能访问数据
* 用户无法直接感知/进行控制
* 实体分类
    * 主体：系统中的活动实体，实际用户、进程
    * 客体：系统中的被动实体，文件、基本表、索引、视图
* 控制规则
    * 读：仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体（低级别的用户不能读高级别的对象，以防高级别数据泄漏）
    * 写：仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体（高级别的用户不能写低级别的对象，以防高级别数据泄漏）

### 完整性

#### 完整性约束条件

| 完整性类型       | 定义                  | SQL 语法示例                                 | 选课系统中的例子                                                                       |
| ----------- | ------------------- | ---------------------------------------- | ------------------------------------------------------------------------------ |
| **实体完整性**   | 主码属性不能为空；每个元组必须唯一标识 | `PRIMARY KEY`                            | 表 `Student(StudentID, Name, ...)` 中，`StudentID` 是主码，必须唯一且非空                    |
| **参照完整性**   | 外码必须引用另一个表中存在的主码或为空 | `FOREIGN KEY (...) REFERENCES ...(...)`  | 表 `Enrollment(StudentID, CourseID, ...)` 中，`StudentID` 引用 `Student(StudentID)` |
| **用户定义完整性** | 业务逻辑约束，由用户根据需求自定义   | `CHECK`、`UNIQUE`、`NOT NULL`、`CONSTRAINT` | `Grade` 表中，`Score` 必须在 0\~100 之间：`CHECK (Score BETWEEN 0 AND 100)`             |

### 数据库设计

#### 垂直/水平分解

* 水平分解：把关系的元组分为若干子集，定义每个子集为一个子关系（按照行拆分表）
    * 使用场景：部分元组较为常用，而其他元组不常用
* 垂直分解：把关系的属性分为若干子集，定义每个子集为一个子关系（按照列拆分表）
    * 优点：提升某些事务效率
    * 缺点：部分事务需要连接操作，降低效率
    * 适用场景：某些属性经常一起使用，且其他属性不经常使用，取决于分解后的总效率是否提高

#### 聚簇

* 原理
    * 独立聚簇：将某属性的值相同的元组集中存放在连续的物理块中，减少磁盘 I/O
    * 组合聚簇：把多个连接的元组按连接属性值聚集存放，加速连接查询
* 目的：提高`ORDER BY`、`GROUP BY`、`UNION`、`DISTINCT`、连接的性能
* 适用场景：教务系统中，学生院系表按照院系聚簇存储，方便查询同一院系的学生信息
* 不适用场景：教务系统中，学生表按照籍贯聚簇，籍贯查询不频繁，聚簇会降低查询效率

#### 索引

* 定义：用于加速数据检索的数据结构，它在数据库表的一个或多个列上创建，用于快速定位满足查询条件的记录，适用于经常用来查询/连接的属性
* 实现方式：B树、B+树、哈希索引、位图索引

```sql
CREATE [UNIQUE] [CLUSTER] INDEX <index_name> ON <table_name> (<column_name> [ASC | DESC], ...)
```

### 事务

#### 事务的特性

* 原子性 Atomicity：要么全做，要么全不做
* 一致性 Consistency：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态（完整性约束没有被破坏）
* 隔离性 Isolation：并发执行的事务之间互不干扰
* 持久性 Durability：事务一旦提交，对数据库的修改是永久性的

#### 转储

* 转储：定期将数据库完整复制到其他介质
* 恢复到故障发生时的状态需重新运行转储以后的所有更新事务

#### 日志

* 记录事务对数据库的更新操作的文件
* 用途：事务故障、系统故障、介质故障恢复
* 登记日志原则
    * 登记次序需严格按照事务的执行顺序
    * 先登记后执行（多一次无效的撤销不会影响数据正确性）
* 恢复方式：重做已完成的事务，撤销未完成的事务

#### 检查点

* 检查点：在日志文件中增加检查点、重新开始文件，动态维护日志
    * 检查点记录：建立时刻正在执行的事务清单，事务最近一个日志记录的地址
    * 重新开始文件：“检查点记录”在日志文件中的地址
* 维护日志文件步骤：周期性建立检查点，保存数据库状态
    1. 将日志缓冲区中的日志写入日志文件
    2. 在日志文件中增加检查点记录
    3. 将数据缓冲区的数据记录写入数据库
    4. 将 检查点记录 在日志文件中的地址写入 重新开始文件
* 恢复步骤
    1. 从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由此找到最后一个检查点记录
    2. 将所有正在执行的事务放入 `ACTIVE` 队列，将 `ACTIVE` 队列中的事务放入 `UNDO` 队列
    3. 从检查点记录开始，向后扫描日志文件
        * 若有新事务：加入 `UNDO` 队列
        * 若有已提交事务：移入 `REDO` 队列
    4. `UNDO` 队列中的事务进行撤销，`REDO` 队列中的事务进行重做

### 并发控制

#### 不一致性

* 丢失修改：A 写后 B 写，导致 A 写的内容**被覆盖**
* 不可重复读：A 读后 B 写后 A 读，当 A 两次读取的**数据不一致**（可能为增/改/删）
* 读脏数据：A 写后 B 读后 A 撤销写，B 读取了**撤销前的数据**，产生错误

#### 锁的种类

| 类型 | 别称     | 上锁者权限   | 他人权限                | 作用            |
| -- | ------ | ------- | ------------------- | ------------- |
| X锁 | 排他锁/写锁 | 独占，可读可写 | 无                   | 写者为避免他人读取错误数据 |
| S锁 | 共享锁/读锁 | 可读      | 可读（只能上 S 锁，不能上 X 锁） | 读者为避免他人修改数据   |

* 步骤题中语法：`Slock X`、`Xlock X`、`Unlock X`

#### 三种封锁协议

| 类型     | 写            | 读            | 丢失修改 | 读脏数据 | 不可重复读 |
| ------ | ------------ | ------------ | ---- | ---- | ----- |
| 一级封锁协议 | 上 X 锁，事务结束释放 | 不上锁          | Y    | N    | N     |
| 二级封锁协议 | 上 X 锁，事务结束释放 | 上 S 锁，读取后释放  | Y    | Y    | N     |
| 三级封锁协议 | 上 X 锁，事务结束释放 | 上 S 锁，事务结束释放 | Y    | Y    | Y     |

#### 死锁活锁

* 活锁：系统先满足后来事务的请求，先来的事务一直在等待锁，无法继续执行
    * 采用先来先服务的方式
* 死锁：两个或多个事务互相等待对方释放锁，导致无法继续执行

#### 解决死锁

* 一次封锁法：事务将所需的数据一次性上锁
* 顺序封锁法：定义上锁顺序，所有事务的上锁顺序一致
* 超时法：事务等待锁的时间超过一定阈值则放弃
* 等待图法：间歇性生成事务等待图，如果存在回路则死锁

#### 两段锁

* 实现步骤
    1. 扩展阶段：在需要用数据前，先上锁
    2. 收缩阶段：释放锁，开始释放锁后不能再上锁
* 两段锁协议 -> 可串行化（仅为充分条件）
    * 不满足两段锁协议的调度不一定不可串行化
* 和一次封锁法的差别：
    * 一次封锁法必须一次性对所有所需数据上锁
    * 两端锁协议更宽松，可上锁后对数据进行操作，随后继续上锁，只需保证上锁和释放过程不交叉
    * 因此两段锁协议的事务可能会发生死锁

#### 意向锁

* 封锁力度：上锁对象的大小
* 多粒度封锁：根据事务所需数据的粒度，动态调整封锁粒度，父节点上锁时，子节点自动上锁
* 目的：提高加锁时系统的检查效率
* 意向锁：当子节点加基本锁时，须对所有父节点加意向锁
    * IS（意向共享锁）：子节点上 S 锁时，父节点上 IS 锁
    * IX（意向排他锁）：子节点上 X 锁时，父节点上 IX 锁
    * SIX（共享意向排他锁）：同时对对象上 S 锁和 IX 锁

| T1\T2 | S | X | IS | IX | SIX | - |
| ----- | - | - | -- | -- | --- | - |
| S     | Y | N | Y  | N  | N   | Y |
| X     | N | N | N  | N  | N   | Y |
| IS    | Y | N | Y  | Y  | Y   | Y |
| IX    | N | N | Y  | Y  | N   | Y |
| SIX   | N | N | Y  | N  | N   | Y |
| -     | Y | Y | Y  | Y  | Y   | Y |

* 具有意向锁的多粒度封锁方法
    * 申请封锁：从上向下对数据库加意向锁，检查是否存在不相容的锁
    * 释放封锁：从下向上
    * 好处：无需检查对象的子对象的锁状态，减少开销

## 理解

> 以下内容多出现在选择/大题中，无需背诵，仅需理解即可

### 关系的基本概念

* 关系：笛卡尔积的子集/二维表
* 元组：关系中的元素/表中的一行
* 属性：表中的一列
* 码
    * 候选码：唯一标识元组的**属性集**，且其任意真子集都不能唯一标识元组
    * 主码：选定多个候选码中的一个
    * 主属性：主码中的属性
    * 外码：表中的属性，引用另一表的主码
* 关系模式：关系的描述，`关系名(属性1, 属性2, ...)`
* 关系模型必须是规范化的，每一个分量是不可分的数据项，属性不能再分

### 基本关系的性质

* 列是同质的：每一列中的分量来自同一个域
* 不同的列可以出自同一个域：不同列的定义域可能相同
* 行、列的顺序无关紧要
* 任何两个元组的候选码不能相同
* 分量必须取原子值：每一个分量都是不可再分的数据项

### 关系运算

* 基本运算符：选择、投影、并、减、笛卡尔积
* 选择（行的运算）：$$\sigma_{F}(R)=\{t | t \in R \land F(t)\}$$，$$F$$ 是布尔表达式（返回真或假），筛选满足 $$F$$ 的元组
* 投影（列的运算）：$$\Pi_{A}(R)=\{t[A] | t \in R\}$$，$$A$$ 是属性名，筛选 $$A$$ 对应的列
    * 可能会导致行的减少：列删除后可能会产生重复的元组
* 连接：$$R \underset{A \theta B}{\bowtie} S = \{\overset{\frown}{t_r t_s} | t_r \in R \land t_s \in S \land (t_r[A] \theta t_s[B])\}$$
    * 在笛卡尔积后，选择符合条件，即$$t_r[A] \theta t_s[B]$$为真的元组
    * 等值连接：$$\theta$$ 是等于号，比较两个属性的值是否相等
    * 自然连接：特殊的等值连接，$$R$$ 和 $$S$$ 中有相同的属性，只保留一次（在行运算的基础上去除重复列）
    * 悬浮元组 Dangling tuple：在自然连接中，$$R$$ 中某些元组有可能在$$S$$中不存在公共属性上值相等的元组，导致$$R$$ 中的元组被舍弃
    * 外连接：保留悬浮元组，空值填充 NULL
    * 左/右外连接：只保留左/右表的悬浮元组，悬浮元组中右/左表独有的属性置为 `NULL`
* 除（行和列的运算）：$$R \div S = \{t_r[X] | t_r \in R \land \Pi_Y(S)\subseteq Y_X \}$$，$$A$$ 和 $$B$$ 是属性名
    * $$R$$有属性$$X$$和$$Y$$，$$S$$有属性$$Y$$,$$Z$$，$$Y_R$$和$$Y_S$$的域相同
    * 找出满足所有$$Y$$的$$X$$（$$X$$的象集能够包含$$\pi_Y(S)$$）
    * $$x$$在$$R$$中的象集：$$Y_x=\{t[Y] | \exists t \in R, t[X]=x\}$$

{% hint style="info" %}
写出查询表达式的题先投影、选择再连接
{% endhint %}

### ER图的绘制

* 实体型：矩形
* 属性：椭圆形
* 联系：菱形
    * 通过无向边连接实体和联系，写上联系类型
    * 联系可以具有属性

### 逻辑结构设计的转换原则

* 实体型 -> 关系模式
    * 实体的属性 -> 关系的属性
    * 实体的码 -> 关系的码
* 1:1 联系
    * -> 独立的关系模式（新开一张表）
    * 和某一端实体对应的关系模式合并（作为某一端的属性）
* 1:n 联系
    * -> 独立的关系模式
    * -> 和n端的对应关系模式合并
* m:n 联系 -> 独立的关系模式
* 多元联系（三个及以上实体间的联系）-> 独立的关系模式
* 具有相同码的关系模式可合并
* **每个实体需加入编号作为主键**
* 需根据题意加入合适的信息：类别、数量……

### 关系范式

#### 数据依赖

* 函数依赖：$$X \to Y$$，属性集 X 可以唯一确定 Y
* 完全函数依赖：Y 依赖于 X 的所有属性，任意 X 的真子集都不能唯一确定 Y
* 传递依赖：$$X \to Y, Y \to Z, Y \nrightarrow X, Z \nsubseteq Y$$，记作$$X \xrightarrow{传递} Z$$
    * 若$$X \to Y , Y \to Z, Y \to X$$，则$$Z$$直接依赖于$$X$$，不算传递函数依赖

#### 定义

* 1NF：每个分量都是不可分的原子值，不能出现多个项$$Y=\{a_1,a_2\}$$的情况
* 2NF：非主属性必须**完全依赖**于候选码，消除部分依赖
* 3NF：非主属性必须**直接依赖**于候选码，消除传递依赖
* BCNF
    * 所有非主属性都完全函数依赖于每个候选码
    * 所有主属性都完全函数依赖于每个不包含它的候选码
    * 没有任何属性完全函数依赖于非码的任何一组属性

#### 提高范式

* 1NF -> 2NF：把部分依赖的候选码和属性拆到新的表内
* 2NF -> 3NF：把传递依赖的候选码和属性拆到新的表内
* 3NF -> BCNF：找出不满足 BCNF 的候选码和属性拆到新的表内

#### 判断流程

> * 候选码：唯一标识元组的**属性集**，且其任意真子集都不能唯一标识元组
> * 主码：选定多个候选码中的一个
> * 主属性：主码中的属性
> * 非主属性：不属于任何候选码的属性
> * 超码：候选码的超集

1. 求候选码、主属性、非主属性
2. 所有函数依赖的左边都是超码 -> BCNF
3. 左边非超码的函数依赖的右边是主属性 -> 3NF
4. 任意候选码的真子集都无法推出非主属性 -> 2NF
5. 所有属性都是原子值 -> 1NF

### 事务调度

* 可串行化调度：多事务并发后的结果和事务按某一顺序串行执行的结果一致
    * 并发调度当且仅当其为可串行化时才是正确调度
* 冲突可串行化：若调度`Sc`在保证冲突操作次序不变的情况下，交换事务不冲突操作的次序，得到串行的调度`Sc'`，则`Sc` 是冲突可串行化的
    * 不能交换的操作：
        * 同一事务的两个操作
        * 不同事务的冲突操作
    * 冲突可串行化 -> 可串行化

### SQL

#### 创建表格

* 列约束：
    * `NOT NULL`：非空约束
    * `UNIQUE`：唯一约束
    * `PRIMARY KEY`：主键约束
* 表约束：
    * `PRIMARY KEY (<column_name>, [<column_name>])`：主键约束，可以包含多个列
    * `FOREIGN KEY (<column_name>) REFERENCES <table_name>(<column_name>)`：外键约束

```sql
CREATE TABLE Course (
  Cno INT PRIMARY KEY,
  Cname CHAR(40) NOT NULL,
  Ccredit SMALLINT,
  FOREIGN KEY (Cpno) REFERENCES Course(Cno)
);
```

#### 查询数据

* `SELECT` 要显示的列
    * 目标列表达式可以是表达式/函数，如`<column_name> + 1`，`LOWER(<column_name>)`
    * 可以使用`AS`给列起别名，也可以不用`AS`，如`SELECT <column_name> AS <alias_name>`，`SELECT <column_name> <alias_name>`
    * `DISTINCT`：去重
    * `ALL`：保留重复值（默认）
    * `*`：所有列
* `FROM` 要查询的表/视图
* `WHERE` 查询条件
    * 比较运算符：`=`, `<>`, `!=`, `<`, `<=`, `>`, `>=`，`!<`, `!>`, `NOT + 运算符`
    * 范围：`BETWEEN <low> AND <high>`，`NOT BETWEEN <low> AND <high>`
    * 包含：`IN (<value>, ...)`，`NOT IN (<value>, ...)`
    * 字符匹配
        * `LIKE`：模糊匹配，`%`表示0个或多个任意字符，`_`表示单个字符
        * `NOT LIKE`
        * 指定转义符：`ESCAPE <escape_char>`，如`LIKE 'A\%' ESCAPE '\'`查询`A%`
    * 空值：`IS NULL`，`IS NOT NULL` 不能用`= NULL`或`<> NULL`
    * 逻辑运算符：`AND`, `OR`, `NOT`
        * 优先级：`NOT` > `AND` > `OR`
        * 可使用括号更改优先级
* `GROUP BY` 按照指定列的值分组
* `HAVING` 分组后的条件
* `ORDER BY` 排序
    * 根据多个列排序：前面的列优先级高

```sql
SELECT [ALL | DISTINCT] <column_name_expr> [ [AS] <column_alias_name>], ...
FROM <table_name|view_name>, ...| (SELECT ...) [AS <alias_name>]
WHERE <condition>
GROUP BY <column_name>, ...
HAVING <condition>
ORDER BY <column_name> [ASC | DESC]
```

#### 聚集函数

* `COUNT(*)`：统计行数
* `COUNT([DISTINCT|ALL] <column_name>)`：统计列数，默认为`ALL`
* `SUM/AVG/MIN/MAX`
* 除了`COUNT(*)`，其他聚集函数跳过空值

#### 对查询结果分组

* `GROUP BY`：分组
* 对查询结果分组后，聚集函数将分别作用于每个组
*   `HAVING`作用于分组后的结果，`WHERE`作用于分组前的所有结果

    * 例：查询平均成绩大于等于90分的学生学号和平均成绩

    ```sql
     SELECT SNO, AVG(SCORE) AS AVG_SCORE
     FROM SC
     GROUP BY SNO
     HAVING AVG(SCORE) >= 90
    ```

#### 连接

```sql
SELECT Student.*, SC.*
FROM Student, SC
WHERE Student.SNO = SC.SNO

-- 自身连接

SELECT FIRST.Cno, SECOND.Cpno
FROM C FIRST, C SECOND
WHERE FIRST.Cpno = SECOND.Cno
```

#### 集合查询

* `SELECT xxx op SELECT yyy`
* `UNION`：并集，去重
* `UNION ALL`：并集，保留重复值
* `INTERSECT`：交集
* `EXCEPT`：差集
* 参与集合操作的查询结果必须列数相同，数据类型相同

#### 插入

```sql
INSERT INTO <table_name> [<column_name>, ...]
VALUES (<value>, ...)
```

#### 更新

```sql
UPDATE <table_name>
SET <column_name> = <value>, ...
WHERE <condition>
```

#### 删除

```sql
DELETE FROM <table_name>
WHERE <condition>
```

#### 空值

* `NULL`参与算术计算时，结果为`NULL`
* `NULL`参与比较时，结果为`UNKNOWN`
* 含有`UNKNOWN`的逻辑运算:`TRUE` > `UNKNOWN` > `FALSE`
    * `NOT UNKNOWN`：`UNKNOWN`
    * `AND`：取“小”的
    * `OR`：取“大”的

#### 建立视图

```sql
CREATE VIEW <view_name> [<column_name>, ...]
AS <query>
[WITH CHECK OPTION]
```

* `<query>`：任意查询语句 `SELECT ... FROM ... WHERE ...`
* `WITH CHECK OPTION`：检查视图的完整性约束，视图的插入、删除、更新操作必须满足视图定义的谓词条件（`WHERE`条件）

```sql
CREATE VIEW F_Student (F_Sno, name, sex, age, dept) AS
SELECT * 
FROM Student
WHERE Ssex = '女';
```
